{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"obs-picamera Documentation : https://gluap.github.io/obs-picamera Source Code : https://github.com/gluap/obs-picamera PyPI : https://pypi.org/project/obs-picamera/ A python module to record video of overtaking events to allow vehicle type identification for OpenBikeSensor overtaking events. Building the device This software should work with a Pi Zero W or Pi Zero 2 with raspberry pi camera independently from the case it's mounted in. The idea is to run this on a raspberry pi zero case which can be somehow mounted on the bicycle. An example case for such a mounting with a list of components used can be found here , compiled STL files to match it are available with logos and without Installation of obs-picamera The software is meant to run on a raspberry pi zero. I suggest installing it with Raspberry Pi os. As prerequisites the following packages are required: sudo apt install python-picamera2 python3-pip The package can then be installed as usual via pip. pip install --user obs-picamera # add --upgrade if you want to upgrade Using obs-picamera You can run the program by calling ( pip install --user has installed the binary in your ~/.local/bin/ ) obs_picamera When it finds an OpenBikeSensor via bluetooth enabled, it will pair with it and whenever it receives an overtaking event - Events for one OpenBikeSensor Track are stored in a directory with the track-id as the directory name. - For each event a short h264 video file is saved, the filename matching the system time of the OpenBikeSensor. - Next to the video file a .json file with the Data from the overtaking event is placed. Its content is self-explanatory. The distance already has the handlebar width deducted. I suggest starting obs_picamera automatically at boot - for instance via crontab entry and switching the pi on while still in the home WIFI (which will enable it to pick up a sensible time). Or one may create a phone wifi for it to pick up the time and date Development Clone this repository Requirements: Poetry Python 3.7+ Create a virtual environment and install the dependencies poetry install Activate the virtual environment poetry shell Testing pytest Documentation The documentation is automatically generated from the content of the docs directory and from the docstrings of the public signatures of the source code. The documentation is updated and published as a Github project page automatically as part each release. Releasing Trigger the Draft release workflow (press Run workflow ). This will update the changelog & version and create a GitHub release which is in Draft state. Find the draft release from the GitHub releases and publish it. When a release is published, it'll trigger release workflow which creates PyPI release and deploys updated documentation. Pre-commit Pre-commit hooks run all the auto-formatters (e.g. black , isort ), linters (e.g. mypy , flake8 ), and other quality checks to make sure the changeset is in good shape before a commit/push happens. You can install the hooks with (runs for each commit): pre-commit install Or if you want them to run only for each push: pre-commit install -t pre-push Or if you want e.g. want to run all checks manually for all files: pre-commit run --all-files This project was generated using the wolt-python-package-cookiecutter template.","title":"Introduction"},{"location":"#obs-picamera","text":"Documentation : https://gluap.github.io/obs-picamera Source Code : https://github.com/gluap/obs-picamera PyPI : https://pypi.org/project/obs-picamera/ A python module to record video of overtaking events to allow vehicle type identification for OpenBikeSensor overtaking events.","title":"obs-picamera"},{"location":"#building-the-device","text":"This software should work with a Pi Zero W or Pi Zero 2 with raspberry pi camera independently from the case it's mounted in. The idea is to run this on a raspberry pi zero case which can be somehow mounted on the bicycle. An example case for such a mounting with a list of components used can be found here , compiled STL files to match it are available with logos and without","title":"Building the device"},{"location":"#installation-of-obs-picamera","text":"The software is meant to run on a raspberry pi zero. I suggest installing it with Raspberry Pi os. As prerequisites the following packages are required: sudo apt install python-picamera2 python3-pip The package can then be installed as usual via pip. pip install --user obs-picamera # add --upgrade if you want to upgrade","title":"Installation of obs-picamera"},{"location":"#using-obs-picamera","text":"You can run the program by calling ( pip install --user has installed the binary in your ~/.local/bin/ ) obs_picamera When it finds an OpenBikeSensor via bluetooth enabled, it will pair with it and whenever it receives an overtaking event - Events for one OpenBikeSensor Track are stored in a directory with the track-id as the directory name. - For each event a short h264 video file is saved, the filename matching the system time of the OpenBikeSensor. - Next to the video file a .json file with the Data from the overtaking event is placed. Its content is self-explanatory. The distance already has the handlebar width deducted. I suggest starting obs_picamera automatically at boot - for instance via crontab entry and switching the pi on while still in the home WIFI (which will enable it to pick up a sensible time). Or one may create a phone wifi for it to pick up the time and date","title":"Using obs-picamera"},{"location":"#development","text":"Clone this repository Requirements: Poetry Python 3.7+ Create a virtual environment and install the dependencies poetry install Activate the virtual environment poetry shell","title":"Development"},{"location":"#testing","text":"pytest","title":"Testing"},{"location":"#documentation","text":"The documentation is automatically generated from the content of the docs directory and from the docstrings of the public signatures of the source code. The documentation is updated and published as a Github project page automatically as part each release.","title":"Documentation"},{"location":"#releasing","text":"Trigger the Draft release workflow (press Run workflow ). This will update the changelog & version and create a GitHub release which is in Draft state. Find the draft release from the GitHub releases and publish it. When a release is published, it'll trigger release workflow which creates PyPI release and deploys updated documentation.","title":"Releasing"},{"location":"#pre-commit","text":"Pre-commit hooks run all the auto-formatters (e.g. black , isort ), linters (e.g. mypy , flake8 ), and other quality checks to make sure the changeset is in good shape before a commit/push happens. You can install the hooks with (runs for each commit): pre-commit install Or if you want them to run only for each push: pre-commit install -t pre-push Or if you want e.g. want to run all checks manually for all files: pre-commit run --all-files This project was generated using the wolt-python-package-cookiecutter template.","title":"Pre-commit"},{"location":"api_docs/","text":"API documentation bluetooth ObsBT Source code in obs_picamera/bluetooth.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class ObsBT : def __init__ ( self , scanner : Optional [ ObsScanner ] = None ) -> None : self . bt_connected : bool = False self . obs_address : str | None = None self . my_scanner : ObsScanner = scanner if scanner is not None else ObsScanner () self . handlebar_left : int = 0 self . handlebar_right : int = 0 self . track_id : str | None = None self . overtaking_callbacks : List [ Callable ] = [] self . recording_callbacks : List [ Callable ] = [] self . bt_connecting : bool = False self . unittesting : bool = False self . history : deque = deque ( maxlen = 100 ) async def find_obs ( self ) -> None : await self . my_scanner . run () if self . obs_address is None : self . obs_address = self . my_scanner . obs_address assert self . obs_address is not None def overtaking_handler ( self , sender : str , data : bytearray ) -> None : \"\"\"Simple notification handler which prints the data received.\"\"\" t , l , r = struct . unpack ( \"Ihh\" , data ) logger . info ( f \"Overtaking event: sensortime: { t } , Left distance { l } , right distance { r } \" ) for callback in self . overtaking_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , history = list ( self . history ), ) def history_handler ( self , sender : str , data : bytearray ) -> None : t , l , r = struct . unpack ( \"Ihh\" , data ) self . history . append ( DistanceMeasurement ( t , l - self . handlebar_left , r - self . handlebar_right ) ) for callback in self . recording_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , ) async def connect ( self ) -> None : def disconnected_callback ( client : bleak . BleakClient ) -> None : logger . info ( \"DISCONNECTED\" ) self . bt_connected = False async with bleak . BleakClient ( self . obs_address , disconnected_callback = disconnected_callback , timeout = 25 # type: ignore ) as client : logger . info ( f \"Connected: { client . is_connected } \" ) await client . start_notify ( CLOSE_PASS_NOTIFICATION_UUID , self . overtaking_handler ) await client . start_notify ( SENSOR_DISTANCE_NOTIFICATION_UUID , self . history_handler ) self . track_id = ( await client . read_gatt_char ( TRACK_ID_UUID )) . decode ( \"utf-8\" ) handlebar = await client . read_gatt_char ( HANDLEBAR_OFFSET_UUID ) self . handlebar_left , self . handlebar_right = struct . unpack ( \"hh\" , handlebar ) logger . info ( f \"track id is { self . track_id } , handlebar: < { self . handlebar_left } | { self . handlebar_right } >\" ) self . bt_connected = True self . bt_connecting = False while True : if not self . bt_connected or self . unittesting : break await asyncio . sleep ( 1 ) async def run ( self ) -> None : await self . find_obs () while not self . bt_connected : try : if not self . bt_connecting : logger . info ( f \"connecting to { self . obs_address } \" ) self . bt_connecting = True assert isinstance ( self . obs_address , str ) await self . connect () else : # pragma: no cover await asyncio . sleep ( 1 ) except BleakError : # pragma: no cover logger . info ( f \"lost connection, reconnecting. connecting= { self . bt_connecting } \" ) overtaking_handler ( sender : str , data : bytearray ) -> None Simple notification handler which prints the data received. Source code in obs_picamera/bluetooth.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def overtaking_handler ( self , sender : str , data : bytearray ) -> None : \"\"\"Simple notification handler which prints the data received.\"\"\" t , l , r = struct . unpack ( \"Ihh\" , data ) logger . info ( f \"Overtaking event: sensortime: { t } , Left distance { l } , right distance { r } \" ) for callback in self . overtaking_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , history = list ( self . history ), ) recorder Recorder Recorder for picamera that starts recording to a ring buffer when initialized and allows to save the last 5 seconds of video from the buffer. Source code in obs_picamera/recorder.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Recorder : \"\"\" Recorder for picamera that starts recording to a ring buffer when initialized and allows to save the last 5 seconds of video from the buffer. \"\"\" def __init__ ( self ) -> None : self . picam2 = Picamera2 () fps = 25 dur = 10 micro = int (( 1 / fps ) * 1000000 ) vconfig = self . picam2 . create_video_configuration ( main = { \"size\" : ( 800 , 606 )}, lores = { \"size\" : ( 800 , 606 )}, encode = \"lores\" ) vconfig [ \"controls\" ][ \"FrameDurationLimits\" ] = ( micro , micro ) self . picam2 . configure ( vconfig ) self . encoder = H264Encoder ( iperiod = 1 , repeat = True , ) self . output = CircularOutput ( buffersize = int ( fps * ( dur + 0.2 )), outputtofile = False ) self . picam2 . start_recording ( self . encoder , self . output , Quality . HIGH ) def save_snippet_to ( self , fp : BinaryIO ) -> None : \"\"\" Save the last 5 seconds of video from the buffer to the filename :param fp: :return: \"\"\" self . output . fileoutput = fp self . output . stop () def jpeg_screenshot ( self ) -> bytes : data = BytesIO () self . picam2 . capture_file ( data , format = \"jpeg\" ) return data . getvalue () def __del__ ( self ) -> None : self . picam2 . stop_recording () save_snippet_to ( fp : BinaryIO ) -> None Save the last 5 seconds of video from the buffer to the filename :param fp: :return: Source code in obs_picamera/recorder.py 34 35 36 37 38 39 40 41 def save_snippet_to ( self , fp : BinaryIO ) -> None : \"\"\" Save the last 5 seconds of video from the buffer to the filename :param fp: :return: \"\"\" self . output . fileoutput = fp self . output . stop () scripts ui Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. MyApp Bases: App Source code in obs_picamera/scripts/ui.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 class MyApp ( App ): def __init__ ( self , * args , recorder = None ): super () . __init__ ( * args ) def idle ( self ): if hasattr ( self , \"data_table\" ): i = 0 for k , v in self . data . items (): i += 1 self . data_table . item_at ( i , 0 ) . set_text ( str ( k )) self . data_table . item_at ( i , 1 ) . set_text ( str ( v )) else : logger . info ( \"no counter\" ) def _get_list_from_app_args ( self , name ): return super () . _get_list_from_app_args ( name ) def preview_screen ( self ) -> gui . Widget : self . to_review = gui . Button ( \"review tracks\" ) tabs = gui . HBox ( children = [ self . to_review ], style = { \"margin\" : \"0px auto\" , \"background-color\" : \"lightgray\" }, ) self . stop_flag = False self . img = RefreshImageWidget ( f \" { API_HOST } /v1/preview.jpeg\" , margin = \"10px\" , width = 0 , height = 0 ) self . video = gui . VideoPlayer ( width = 806 , height = 600 ) self . check = gui . CheckBoxLabel ( \"Preview\" , False , width = 200 , height = 30 , margin = \"10px\" ) self . data_table = gui . TableWidget ( 8 , 2 ) self . data_table . item_at ( 0 , 0 ) . set_text ( \"k\" ) self . data_table . item_at ( 0 , 1 ) . set_text ( \"v\" ) self . check . onchange . do ( self . on_check_change ) video_container = gui . VBox ( [ tabs , self . img , self . check , self . data_table ], margin = \"8pt auto\" ) self . refresh = False self . running = True return video_container def review_screen ( self ) -> gui . Widget : self . to_preview = gui . Button ( \"change page\" ) reviewcontainer = gui . HBox ( children = [ self . to_preview ], style = { \"margin\" : \"0px auto\" , \"background-color\" : \"lightgray\" }, ) return reviewcontainer def main ( self ): self . data = {} # self.recorder = Recorder() self . previewcontainer = self . preview_screen () self . reviewcontainer = self . review_screen () self . to_review . onclick . do ( self . set_different_root_widget , self . reviewcontainer ) self . to_preview . onclick . do ( self . set_different_root_widget , self . previewcontainer ) t = threading . Thread ( target = self . update ) t . start () return self . reviewcontainer def set_different_root_widget ( self , emitter , page_to_be_shown ): self . set_root_widget ( page_to_be_shown ) self . check . set_value ( False ) self . refresh = False def update_data ( self ): try : current = requests . get ( f \" { API_HOST } /v1/state\" ) self . data = json . loads ( current . content ) except requests . RequestException : pass def update ( self ): lasttime : int = 0 while self . running : time . sleep ( 0.1 ) if self . refresh and lasttime != int ( time . time ()): self . img . load () lasttime = int ( time . time ()) self . update_data () def __main ( self ): # the margin 0px auto centers the main container verticalContainer = gui . Container ( width = 540 , margin = \"0px auto\" , style = { \"display\" : \"block\" , \"overflow\" : \"hidden\" }, ) horizontalContainer = gui . Container ( width = \"100%\" , layout_orientation = gui . Container . LAYOUT_HORIZONTAL , margin = \"0px\" , style = { \"display\" : \"block\" , \"overflow\" : \"auto\" }, ) subContainerLeft = gui . Container ( width = 320 , style = { \"display\" : \"block\" , \"overflow\" : \"auto\" , \"text-align\" : \"center\" }, ) self . img = gui . Image ( \"/res:logo.png\" , height = 100 , margin = \"10px\" ) self . img . onclick . do ( self . on_img_clicked ) self . table = gui . Table . new_from_list ( [ ( \"ID\" , \"First Name\" , \"Last Name\" ), ( \"101\" , \"Danny\" , \"Young\" ), ( \"102\" , \"Christine\" , \"Holand\" ), ( \"103\" , \"Lars\" , \"Gordon\" ), ( \"104\" , \"Roberto\" , \"Robitaille\" ), ( \"105\" , \"Maria\" , \"Papadopoulos\" ), ], width = 300 , height = 200 , margin = \"10px\" , ) self . table . on_table_row_click . do ( self . on_table_row_click ) # the arguments are width - height - layoutOrientationOrizontal subContainerRight = gui . Container ( style = { \"width\" : \"220px\" , \"display\" : \"block\" , \"overflow\" : \"auto\" , \"text-align\" : \"center\" , } ) self . count = 0 self . counter = gui . Label ( \"\" , width = 200 , height = 30 , margin = \"10px\" ) self . lbl = gui . Label ( \"This is a LABEL!\" , width = 200 , height = 30 , margin = \"10px\" ) self . bt = gui . Button ( \"Press me!\" , width = 200 , height = 30 , margin = \"10px\" ) # setting the listener for the onclick event of the button self . bt . onclick . do ( self . on_button_pressed ) self . txt = gui . TextInput ( width = 200 , height = 30 , margin = \"10px\" ) self . txt . set_text ( \"This is a TEXTAREA\" ) self . txt . onchange . do ( self . on_text_area_change ) self . spin = gui . SpinBox ( 1 , 0 , 100 , width = 200 , height = 30 , margin = \"10px\" ) self . spin . onchange . do ( self . on_spin_change ) self . progress = gui . Progress ( 1 , 100 , width = 200 , height = 5 ) self . check = gui . CheckBoxLabel ( \"Label checkbox\" , True , width = 200 , height = 30 , margin = \"10px\" ) self . check . onchange . do ( self . on_check_change ) self . btInputDiag = gui . Button ( \"Open InputDialog\" , width = 200 , height = 30 , margin = \"10px\" ) self . btInputDiag . onclick . do ( self . open_input_dialog ) self . btFileDiag = gui . Button ( \"File Selection Dialog\" , width = 200 , height = 30 , margin = \"10px\" ) self . btFileDiag . onclick . do ( self . open_fileselection_dialog ) self . btUploadFile = gui . FileUploader ( \"./\" , width = 200 , height = 30 , margin = \"10px\" ) self . btUploadFile . onsuccess . do ( self . fileupload_on_success ) self . btUploadFile . onfailed . do ( self . fileupload_on_failed ) items = ( \"Danny Young\" , \"Christine Holand\" , \"Lars Gordon\" , \"Roberto Robitaille\" ) self . listView = gui . ListView . new_from_list ( items , width = 300 , height = 120 , margin = \"10px\" ) self . listView . onselection . do ( self . list_view_on_selected ) self . link = gui . Link ( \"http://localhost:8081\" , \"A link to here\" , width = 200 , height = 30 , margin = \"10px\" , ) self . dropDown = gui . DropDown . new_from_list ( ( \"DropDownItem 0\" , \"DropDownItem 1\" ), width = 200 , height = 20 , margin = \"10px\" ) self . dropDown . onchange . do ( self . drop_down_changed ) self . dropDown . select_by_value ( \"DropDownItem 0\" ) self . slider = gui . Slider ( 10 , 0 , 100 , 5 , width = 200 , height = 20 , margin = \"10px\" ) self . slider . onchange . do ( self . slider_changed ) self . colorPicker = gui . ColorPicker ( \"#ffbb00\" , width = 200 , height = 20 , margin = \"10px\" ) self . colorPicker . onchange . do ( self . color_picker_changed ) self . date = gui . Date ( \"2015-04-13\" , width = 200 , height = 20 , margin = \"10px\" ) self . date . onchange . do ( self . date_changed ) self . video = gui . Widget ( _type = \"iframe\" , width = 290 , height = 200 , margin = \"10px\" ) self . video . attributes [ \"src\" ] = \"https://drive.google.com/file/d/0B0J9Lq_MRyn4UFRsblR3UTBZRHc/preview\" self . video . attributes [ \"width\" ] = \"100%\" self . video . attributes [ \"height\" ] = \"100%\" self . video . attributes [ \"controls\" ] = \"true\" self . video . style [ \"border\" ] = \"none\" self . tree = gui . TreeView ( width = \"100%\" , height = 300 ) ti1 = gui . TreeItem ( \"Item1\" ) ti2 = gui . TreeItem ( \"Item2\" ) ti3 = gui . TreeItem ( \"Item3\" ) subti1 = gui . TreeItem ( \"Sub Item1\" ) subti2 = gui . TreeItem ( \"Sub Item2\" ) subti3 = gui . TreeItem ( \"Sub Item3\" ) subti4 = gui . TreeItem ( \"Sub Item4\" ) subsubti1 = gui . TreeItem ( \"Sub Sub Item1\" ) subsubti2 = gui . TreeItem ( \"Sub Sub Item2\" ) subsubti3 = gui . TreeItem ( \"Sub Sub Item3\" ) self . tree . append ([ ti1 , ti2 , ti3 ]) ti2 . append ([ subti1 , subti2 , subti3 , subti4 ]) subti4 . append ([ subsubti1 , subsubti2 , subsubti3 ]) # appending a widget to another, the first argument is a string key subContainerRight . append ( [ self . counter , self . lbl , self . bt , self . txt , self . spin , self . progress , self . check , self . btInputDiag , self . btFileDiag , ] ) # use a defined key as we replace this widget later fdownloader = gui . FileDownloader ( \"download test\" , \"../remi/res/logo.png\" , width = 200 , height = 30 , margin = \"10px\" ) subContainerRight . append ( fdownloader , key = \"file_downloader\" ) subContainerRight . append ( [ self . btUploadFile , self . dropDown , self . slider , self . colorPicker , self . date , self . tree , ] ) self . subContainerRight = subContainerRight subContainerLeft . append ( [ self . img , self . table , self . listView , self . link , self . video ] ) horizontalContainer . append ([ subContainerLeft , subContainerRight ]) menu = gui . Menu ( width = \"100%\" , height = \"30px\" ) m1 = gui . MenuItem ( \"File\" , width = 100 , height = 30 ) m2 = gui . MenuItem ( \"View\" , width = 100 , height = 30 ) m2 . onclick . do ( self . menu_view_clicked ) m11 = gui . MenuItem ( \"Save\" , width = 100 , height = 30 ) m12 = gui . MenuItem ( \"Open\" , width = 100 , height = 30 ) m12 . onclick . do ( self . menu_open_clicked ) m111 = gui . MenuItem ( \"Save\" , width = 100 , height = 30 ) m111 . onclick . do ( self . menu_save_clicked ) m112 = gui . MenuItem ( \"Save as\" , width = 100 , height = 30 ) m112 . onclick . do ( self . menu_saveas_clicked ) m3 = gui . MenuItem ( \"Dialog\" , width = 100 , height = 30 ) m3 . onclick . do ( self . menu_dialog_clicked ) menu . append ([ m1 , m2 , m3 ]) m1 . append ([ m11 , m12 ]) m11 . append ([ m111 , m112 ]) menubar = gui . MenuBar ( width = \"100%\" , height = \"30px\" ) menubar . append ( menu ) verticalContainer . append ([ menubar , horizontalContainer ]) # this flag will be used to stop the display_counter Timer self . stop_flag = False # kick of regular display of counter self . display_counter () # returning the root widget return verticalContainer # listener function def on_img_clicked ( self , widget ): self . lbl . set_text ( \"Image clicked!\" ) def on_table_row_click ( self , table , row , item ): self . lbl . set_text ( \"Table Item clicked: \" + item . get_text ()) def on_button_pressed ( self , widget ): self . lbl . set_text ( \"Button pressed! \" ) self . bt . set_text ( \"Hi!\" ) def on_text_area_change ( self , widget , newValue ): self . lbl . set_text ( \"Text Area value changed!\" ) def on_spin_change ( self , widget , newValue ): self . lbl . set_text ( \"SpinBox changed, new value: \" + str ( newValue )) def on_check_change ( self , widget , newValue ): self . refresh = newValue if self . refresh : self . img . set_size ( 806 , 600 ) else : self . img . set_size ( 0 , 0 ) def open_input_dialog ( self , widget ): self . inputDialog = gui . InputDialog ( \"Input Dialog\" , \"Your name?\" , initial_value = \"type here\" , width = 500 ) self . inputDialog . confirm_value . do ( self . on_input_dialog_confirm ) # here is returned the Input Dialog widget, and it will be shown self . inputDialog . show ( self ) def on_input_dialog_confirm ( self , widget , value ): self . lbl . set_text ( \"Hello \" + value ) def open_fileselection_dialog ( self , widget ): self . fileselectionDialog = gui . FileSelectionDialog ( \"File Selection Dialog\" , \"Select files and folders\" , False , \".\" ) self . fileselectionDialog . confirm_value . do ( self . on_fileselection_dialog_confirm ) # here is returned the Input Dialog widget, and it will be shown self . fileselectionDialog . show ( self ) def on_fileselection_dialog_confirm ( self , widget , filelist ): # a list() of filenames and folders is returned self . lbl . set_text ( \"Selected files: %s \" % \",\" . join ( filelist )) if len ( filelist ): f = filelist [ 0 ] # replace the last download link fdownloader = gui . FileDownloader ( \"download selected\" , f , width = 200 , height = 30 ) self . subContainerRight . append ( fdownloader , key = \"file_downloader\" ) def list_view_on_selected ( self , widget , selected_item_key ): \"\"\"The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly \"\"\" self . lbl . set_text ( \"List selection: \" + self . listView . children [ selected_item_key ] . get_text () ) def drop_down_changed ( self , widget , value ): self . lbl . set_text ( \"New Combo value: \" + value ) def slider_changed ( self , widget , value ): self . lbl . set_text ( \"New slider value: \" + str ( value )) def color_picker_changed ( self , widget , value ): self . lbl . set_text ( \"New color value: \" + value ) def date_changed ( self , widget , value ): self . lbl . set_text ( \"New date value: \" + value ) def menu_save_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Save\" ) def menu_saveas_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Save As\" ) def menu_open_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Open\" ) def menu_view_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: View\" ) def fileupload_on_success ( self , widget , filename ): self . lbl . set_text ( \"File upload success: \" + filename ) def fileupload_on_failed ( self , widget , filename ): self . lbl . set_text ( \"File upload failed: \" + filename ) def on_close ( self ): \"\"\"Overloading App.on_close event to stop the Timer.\"\"\" self . stop_flag = True self . running = False super () . on_close () list_view_on_selected ( widget , selected_item_key ) The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly Source code in obs_picamera/scripts/ui.py 452 453 454 455 456 457 458 def list_view_on_selected ( self , widget , selected_item_key ): \"\"\"The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly \"\"\" self . lbl . set_text ( \"List selection: \" + self . listView . children [ selected_item_key ] . get_text () ) on_close () Overloading App.on_close event to stop the Timer. Source code in obs_picamera/scripts/ui.py 490 491 492 493 494 495 def on_close ( self ): \"\"\"Overloading App.on_close event to stop the Timer.\"\"\" self . stop_flag = True self . running = False super () . on_close ()","title":"API documentation"},{"location":"api_docs/#api-documentation","text":"","title":"API documentation"},{"location":"api_docs/#obs_picamera.bluetooth","text":"","title":"bluetooth"},{"location":"api_docs/#obs_picamera.bluetooth.ObsBT","text":"Source code in obs_picamera/bluetooth.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class ObsBT : def __init__ ( self , scanner : Optional [ ObsScanner ] = None ) -> None : self . bt_connected : bool = False self . obs_address : str | None = None self . my_scanner : ObsScanner = scanner if scanner is not None else ObsScanner () self . handlebar_left : int = 0 self . handlebar_right : int = 0 self . track_id : str | None = None self . overtaking_callbacks : List [ Callable ] = [] self . recording_callbacks : List [ Callable ] = [] self . bt_connecting : bool = False self . unittesting : bool = False self . history : deque = deque ( maxlen = 100 ) async def find_obs ( self ) -> None : await self . my_scanner . run () if self . obs_address is None : self . obs_address = self . my_scanner . obs_address assert self . obs_address is not None def overtaking_handler ( self , sender : str , data : bytearray ) -> None : \"\"\"Simple notification handler which prints the data received.\"\"\" t , l , r = struct . unpack ( \"Ihh\" , data ) logger . info ( f \"Overtaking event: sensortime: { t } , Left distance { l } , right distance { r } \" ) for callback in self . overtaking_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , history = list ( self . history ), ) def history_handler ( self , sender : str , data : bytearray ) -> None : t , l , r = struct . unpack ( \"Ihh\" , data ) self . history . append ( DistanceMeasurement ( t , l - self . handlebar_left , r - self . handlebar_right ) ) for callback in self . recording_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , ) async def connect ( self ) -> None : def disconnected_callback ( client : bleak . BleakClient ) -> None : logger . info ( \"DISCONNECTED\" ) self . bt_connected = False async with bleak . BleakClient ( self . obs_address , disconnected_callback = disconnected_callback , timeout = 25 # type: ignore ) as client : logger . info ( f \"Connected: { client . is_connected } \" ) await client . start_notify ( CLOSE_PASS_NOTIFICATION_UUID , self . overtaking_handler ) await client . start_notify ( SENSOR_DISTANCE_NOTIFICATION_UUID , self . history_handler ) self . track_id = ( await client . read_gatt_char ( TRACK_ID_UUID )) . decode ( \"utf-8\" ) handlebar = await client . read_gatt_char ( HANDLEBAR_OFFSET_UUID ) self . handlebar_left , self . handlebar_right = struct . unpack ( \"hh\" , handlebar ) logger . info ( f \"track id is { self . track_id } , handlebar: < { self . handlebar_left } | { self . handlebar_right } >\" ) self . bt_connected = True self . bt_connecting = False while True : if not self . bt_connected or self . unittesting : break await asyncio . sleep ( 1 ) async def run ( self ) -> None : await self . find_obs () while not self . bt_connected : try : if not self . bt_connecting : logger . info ( f \"connecting to { self . obs_address } \" ) self . bt_connecting = True assert isinstance ( self . obs_address , str ) await self . connect () else : # pragma: no cover await asyncio . sleep ( 1 ) except BleakError : # pragma: no cover logger . info ( f \"lost connection, reconnecting. connecting= { self . bt_connecting } \" )","title":"ObsBT"},{"location":"api_docs/#obs_picamera.bluetooth.ObsBT.overtaking_handler","text":"Simple notification handler which prints the data received. Source code in obs_picamera/bluetooth.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def overtaking_handler ( self , sender : str , data : bytearray ) -> None : \"\"\"Simple notification handler which prints the data received.\"\"\" t , l , r = struct . unpack ( \"Ihh\" , data ) logger . info ( f \"Overtaking event: sensortime: { t } , Left distance { l } , right distance { r } \" ) for callback in self . overtaking_callbacks : callback ( distance_l = l - self . handlebar_left , distance_r = r - self . handlebar_right , handlebars_l = self . handlebar_left , handlebar_r = self . handlebar_right , track_id = self . track_id , sensortime = t , history = list ( self . history ), )","title":"overtaking_handler()"},{"location":"api_docs/#obs_picamera.recorder","text":"","title":"recorder"},{"location":"api_docs/#obs_picamera.recorder.Recorder","text":"Recorder for picamera that starts recording to a ring buffer when initialized and allows to save the last 5 seconds of video from the buffer. Source code in obs_picamera/recorder.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Recorder : \"\"\" Recorder for picamera that starts recording to a ring buffer when initialized and allows to save the last 5 seconds of video from the buffer. \"\"\" def __init__ ( self ) -> None : self . picam2 = Picamera2 () fps = 25 dur = 10 micro = int (( 1 / fps ) * 1000000 ) vconfig = self . picam2 . create_video_configuration ( main = { \"size\" : ( 800 , 606 )}, lores = { \"size\" : ( 800 , 606 )}, encode = \"lores\" ) vconfig [ \"controls\" ][ \"FrameDurationLimits\" ] = ( micro , micro ) self . picam2 . configure ( vconfig ) self . encoder = H264Encoder ( iperiod = 1 , repeat = True , ) self . output = CircularOutput ( buffersize = int ( fps * ( dur + 0.2 )), outputtofile = False ) self . picam2 . start_recording ( self . encoder , self . output , Quality . HIGH ) def save_snippet_to ( self , fp : BinaryIO ) -> None : \"\"\" Save the last 5 seconds of video from the buffer to the filename :param fp: :return: \"\"\" self . output . fileoutput = fp self . output . stop () def jpeg_screenshot ( self ) -> bytes : data = BytesIO () self . picam2 . capture_file ( data , format = \"jpeg\" ) return data . getvalue () def __del__ ( self ) -> None : self . picam2 . stop_recording ()","title":"Recorder"},{"location":"api_docs/#obs_picamera.recorder.Recorder.save_snippet_to","text":"Save the last 5 seconds of video from the buffer to the filename :param fp: :return: Source code in obs_picamera/recorder.py 34 35 36 37 38 39 40 41 def save_snippet_to ( self , fp : BinaryIO ) -> None : \"\"\" Save the last 5 seconds of video from the buffer to the filename :param fp: :return: \"\"\" self . output . fileoutput = fp self . output . stop ()","title":"save_snippet_to()"},{"location":"api_docs/#obs_picamera.scripts","text":"","title":"scripts"},{"location":"api_docs/#obs_picamera.scripts.ui","text":"Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"ui"},{"location":"api_docs/#obs_picamera.scripts.ui.MyApp","text":"Bases: App Source code in obs_picamera/scripts/ui.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 class MyApp ( App ): def __init__ ( self , * args , recorder = None ): super () . __init__ ( * args ) def idle ( self ): if hasattr ( self , \"data_table\" ): i = 0 for k , v in self . data . items (): i += 1 self . data_table . item_at ( i , 0 ) . set_text ( str ( k )) self . data_table . item_at ( i , 1 ) . set_text ( str ( v )) else : logger . info ( \"no counter\" ) def _get_list_from_app_args ( self , name ): return super () . _get_list_from_app_args ( name ) def preview_screen ( self ) -> gui . Widget : self . to_review = gui . Button ( \"review tracks\" ) tabs = gui . HBox ( children = [ self . to_review ], style = { \"margin\" : \"0px auto\" , \"background-color\" : \"lightgray\" }, ) self . stop_flag = False self . img = RefreshImageWidget ( f \" { API_HOST } /v1/preview.jpeg\" , margin = \"10px\" , width = 0 , height = 0 ) self . video = gui . VideoPlayer ( width = 806 , height = 600 ) self . check = gui . CheckBoxLabel ( \"Preview\" , False , width = 200 , height = 30 , margin = \"10px\" ) self . data_table = gui . TableWidget ( 8 , 2 ) self . data_table . item_at ( 0 , 0 ) . set_text ( \"k\" ) self . data_table . item_at ( 0 , 1 ) . set_text ( \"v\" ) self . check . onchange . do ( self . on_check_change ) video_container = gui . VBox ( [ tabs , self . img , self . check , self . data_table ], margin = \"8pt auto\" ) self . refresh = False self . running = True return video_container def review_screen ( self ) -> gui . Widget : self . to_preview = gui . Button ( \"change page\" ) reviewcontainer = gui . HBox ( children = [ self . to_preview ], style = { \"margin\" : \"0px auto\" , \"background-color\" : \"lightgray\" }, ) return reviewcontainer def main ( self ): self . data = {} # self.recorder = Recorder() self . previewcontainer = self . preview_screen () self . reviewcontainer = self . review_screen () self . to_review . onclick . do ( self . set_different_root_widget , self . reviewcontainer ) self . to_preview . onclick . do ( self . set_different_root_widget , self . previewcontainer ) t = threading . Thread ( target = self . update ) t . start () return self . reviewcontainer def set_different_root_widget ( self , emitter , page_to_be_shown ): self . set_root_widget ( page_to_be_shown ) self . check . set_value ( False ) self . refresh = False def update_data ( self ): try : current = requests . get ( f \" { API_HOST } /v1/state\" ) self . data = json . loads ( current . content ) except requests . RequestException : pass def update ( self ): lasttime : int = 0 while self . running : time . sleep ( 0.1 ) if self . refresh and lasttime != int ( time . time ()): self . img . load () lasttime = int ( time . time ()) self . update_data () def __main ( self ): # the margin 0px auto centers the main container verticalContainer = gui . Container ( width = 540 , margin = \"0px auto\" , style = { \"display\" : \"block\" , \"overflow\" : \"hidden\" }, ) horizontalContainer = gui . Container ( width = \"100%\" , layout_orientation = gui . Container . LAYOUT_HORIZONTAL , margin = \"0px\" , style = { \"display\" : \"block\" , \"overflow\" : \"auto\" }, ) subContainerLeft = gui . Container ( width = 320 , style = { \"display\" : \"block\" , \"overflow\" : \"auto\" , \"text-align\" : \"center\" }, ) self . img = gui . Image ( \"/res:logo.png\" , height = 100 , margin = \"10px\" ) self . img . onclick . do ( self . on_img_clicked ) self . table = gui . Table . new_from_list ( [ ( \"ID\" , \"First Name\" , \"Last Name\" ), ( \"101\" , \"Danny\" , \"Young\" ), ( \"102\" , \"Christine\" , \"Holand\" ), ( \"103\" , \"Lars\" , \"Gordon\" ), ( \"104\" , \"Roberto\" , \"Robitaille\" ), ( \"105\" , \"Maria\" , \"Papadopoulos\" ), ], width = 300 , height = 200 , margin = \"10px\" , ) self . table . on_table_row_click . do ( self . on_table_row_click ) # the arguments are width - height - layoutOrientationOrizontal subContainerRight = gui . Container ( style = { \"width\" : \"220px\" , \"display\" : \"block\" , \"overflow\" : \"auto\" , \"text-align\" : \"center\" , } ) self . count = 0 self . counter = gui . Label ( \"\" , width = 200 , height = 30 , margin = \"10px\" ) self . lbl = gui . Label ( \"This is a LABEL!\" , width = 200 , height = 30 , margin = \"10px\" ) self . bt = gui . Button ( \"Press me!\" , width = 200 , height = 30 , margin = \"10px\" ) # setting the listener for the onclick event of the button self . bt . onclick . do ( self . on_button_pressed ) self . txt = gui . TextInput ( width = 200 , height = 30 , margin = \"10px\" ) self . txt . set_text ( \"This is a TEXTAREA\" ) self . txt . onchange . do ( self . on_text_area_change ) self . spin = gui . SpinBox ( 1 , 0 , 100 , width = 200 , height = 30 , margin = \"10px\" ) self . spin . onchange . do ( self . on_spin_change ) self . progress = gui . Progress ( 1 , 100 , width = 200 , height = 5 ) self . check = gui . CheckBoxLabel ( \"Label checkbox\" , True , width = 200 , height = 30 , margin = \"10px\" ) self . check . onchange . do ( self . on_check_change ) self . btInputDiag = gui . Button ( \"Open InputDialog\" , width = 200 , height = 30 , margin = \"10px\" ) self . btInputDiag . onclick . do ( self . open_input_dialog ) self . btFileDiag = gui . Button ( \"File Selection Dialog\" , width = 200 , height = 30 , margin = \"10px\" ) self . btFileDiag . onclick . do ( self . open_fileselection_dialog ) self . btUploadFile = gui . FileUploader ( \"./\" , width = 200 , height = 30 , margin = \"10px\" ) self . btUploadFile . onsuccess . do ( self . fileupload_on_success ) self . btUploadFile . onfailed . do ( self . fileupload_on_failed ) items = ( \"Danny Young\" , \"Christine Holand\" , \"Lars Gordon\" , \"Roberto Robitaille\" ) self . listView = gui . ListView . new_from_list ( items , width = 300 , height = 120 , margin = \"10px\" ) self . listView . onselection . do ( self . list_view_on_selected ) self . link = gui . Link ( \"http://localhost:8081\" , \"A link to here\" , width = 200 , height = 30 , margin = \"10px\" , ) self . dropDown = gui . DropDown . new_from_list ( ( \"DropDownItem 0\" , \"DropDownItem 1\" ), width = 200 , height = 20 , margin = \"10px\" ) self . dropDown . onchange . do ( self . drop_down_changed ) self . dropDown . select_by_value ( \"DropDownItem 0\" ) self . slider = gui . Slider ( 10 , 0 , 100 , 5 , width = 200 , height = 20 , margin = \"10px\" ) self . slider . onchange . do ( self . slider_changed ) self . colorPicker = gui . ColorPicker ( \"#ffbb00\" , width = 200 , height = 20 , margin = \"10px\" ) self . colorPicker . onchange . do ( self . color_picker_changed ) self . date = gui . Date ( \"2015-04-13\" , width = 200 , height = 20 , margin = \"10px\" ) self . date . onchange . do ( self . date_changed ) self . video = gui . Widget ( _type = \"iframe\" , width = 290 , height = 200 , margin = \"10px\" ) self . video . attributes [ \"src\" ] = \"https://drive.google.com/file/d/0B0J9Lq_MRyn4UFRsblR3UTBZRHc/preview\" self . video . attributes [ \"width\" ] = \"100%\" self . video . attributes [ \"height\" ] = \"100%\" self . video . attributes [ \"controls\" ] = \"true\" self . video . style [ \"border\" ] = \"none\" self . tree = gui . TreeView ( width = \"100%\" , height = 300 ) ti1 = gui . TreeItem ( \"Item1\" ) ti2 = gui . TreeItem ( \"Item2\" ) ti3 = gui . TreeItem ( \"Item3\" ) subti1 = gui . TreeItem ( \"Sub Item1\" ) subti2 = gui . TreeItem ( \"Sub Item2\" ) subti3 = gui . TreeItem ( \"Sub Item3\" ) subti4 = gui . TreeItem ( \"Sub Item4\" ) subsubti1 = gui . TreeItem ( \"Sub Sub Item1\" ) subsubti2 = gui . TreeItem ( \"Sub Sub Item2\" ) subsubti3 = gui . TreeItem ( \"Sub Sub Item3\" ) self . tree . append ([ ti1 , ti2 , ti3 ]) ti2 . append ([ subti1 , subti2 , subti3 , subti4 ]) subti4 . append ([ subsubti1 , subsubti2 , subsubti3 ]) # appending a widget to another, the first argument is a string key subContainerRight . append ( [ self . counter , self . lbl , self . bt , self . txt , self . spin , self . progress , self . check , self . btInputDiag , self . btFileDiag , ] ) # use a defined key as we replace this widget later fdownloader = gui . FileDownloader ( \"download test\" , \"../remi/res/logo.png\" , width = 200 , height = 30 , margin = \"10px\" ) subContainerRight . append ( fdownloader , key = \"file_downloader\" ) subContainerRight . append ( [ self . btUploadFile , self . dropDown , self . slider , self . colorPicker , self . date , self . tree , ] ) self . subContainerRight = subContainerRight subContainerLeft . append ( [ self . img , self . table , self . listView , self . link , self . video ] ) horizontalContainer . append ([ subContainerLeft , subContainerRight ]) menu = gui . Menu ( width = \"100%\" , height = \"30px\" ) m1 = gui . MenuItem ( \"File\" , width = 100 , height = 30 ) m2 = gui . MenuItem ( \"View\" , width = 100 , height = 30 ) m2 . onclick . do ( self . menu_view_clicked ) m11 = gui . MenuItem ( \"Save\" , width = 100 , height = 30 ) m12 = gui . MenuItem ( \"Open\" , width = 100 , height = 30 ) m12 . onclick . do ( self . menu_open_clicked ) m111 = gui . MenuItem ( \"Save\" , width = 100 , height = 30 ) m111 . onclick . do ( self . menu_save_clicked ) m112 = gui . MenuItem ( \"Save as\" , width = 100 , height = 30 ) m112 . onclick . do ( self . menu_saveas_clicked ) m3 = gui . MenuItem ( \"Dialog\" , width = 100 , height = 30 ) m3 . onclick . do ( self . menu_dialog_clicked ) menu . append ([ m1 , m2 , m3 ]) m1 . append ([ m11 , m12 ]) m11 . append ([ m111 , m112 ]) menubar = gui . MenuBar ( width = \"100%\" , height = \"30px\" ) menubar . append ( menu ) verticalContainer . append ([ menubar , horizontalContainer ]) # this flag will be used to stop the display_counter Timer self . stop_flag = False # kick of regular display of counter self . display_counter () # returning the root widget return verticalContainer # listener function def on_img_clicked ( self , widget ): self . lbl . set_text ( \"Image clicked!\" ) def on_table_row_click ( self , table , row , item ): self . lbl . set_text ( \"Table Item clicked: \" + item . get_text ()) def on_button_pressed ( self , widget ): self . lbl . set_text ( \"Button pressed! \" ) self . bt . set_text ( \"Hi!\" ) def on_text_area_change ( self , widget , newValue ): self . lbl . set_text ( \"Text Area value changed!\" ) def on_spin_change ( self , widget , newValue ): self . lbl . set_text ( \"SpinBox changed, new value: \" + str ( newValue )) def on_check_change ( self , widget , newValue ): self . refresh = newValue if self . refresh : self . img . set_size ( 806 , 600 ) else : self . img . set_size ( 0 , 0 ) def open_input_dialog ( self , widget ): self . inputDialog = gui . InputDialog ( \"Input Dialog\" , \"Your name?\" , initial_value = \"type here\" , width = 500 ) self . inputDialog . confirm_value . do ( self . on_input_dialog_confirm ) # here is returned the Input Dialog widget, and it will be shown self . inputDialog . show ( self ) def on_input_dialog_confirm ( self , widget , value ): self . lbl . set_text ( \"Hello \" + value ) def open_fileselection_dialog ( self , widget ): self . fileselectionDialog = gui . FileSelectionDialog ( \"File Selection Dialog\" , \"Select files and folders\" , False , \".\" ) self . fileselectionDialog . confirm_value . do ( self . on_fileselection_dialog_confirm ) # here is returned the Input Dialog widget, and it will be shown self . fileselectionDialog . show ( self ) def on_fileselection_dialog_confirm ( self , widget , filelist ): # a list() of filenames and folders is returned self . lbl . set_text ( \"Selected files: %s \" % \",\" . join ( filelist )) if len ( filelist ): f = filelist [ 0 ] # replace the last download link fdownloader = gui . FileDownloader ( \"download selected\" , f , width = 200 , height = 30 ) self . subContainerRight . append ( fdownloader , key = \"file_downloader\" ) def list_view_on_selected ( self , widget , selected_item_key ): \"\"\"The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly \"\"\" self . lbl . set_text ( \"List selection: \" + self . listView . children [ selected_item_key ] . get_text () ) def drop_down_changed ( self , widget , value ): self . lbl . set_text ( \"New Combo value: \" + value ) def slider_changed ( self , widget , value ): self . lbl . set_text ( \"New slider value: \" + str ( value )) def color_picker_changed ( self , widget , value ): self . lbl . set_text ( \"New color value: \" + value ) def date_changed ( self , widget , value ): self . lbl . set_text ( \"New date value: \" + value ) def menu_save_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Save\" ) def menu_saveas_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Save As\" ) def menu_open_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: Open\" ) def menu_view_clicked ( self , widget ): self . lbl . set_text ( \"Menu clicked: View\" ) def fileupload_on_success ( self , widget , filename ): self . lbl . set_text ( \"File upload success: \" + filename ) def fileupload_on_failed ( self , widget , filename ): self . lbl . set_text ( \"File upload failed: \" + filename ) def on_close ( self ): \"\"\"Overloading App.on_close event to stop the Timer.\"\"\" self . stop_flag = True self . running = False super () . on_close ()","title":"MyApp"},{"location":"api_docs/#obs_picamera.scripts.ui.MyApp.list_view_on_selected","text":"The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly Source code in obs_picamera/scripts/ui.py 452 453 454 455 456 457 458 def list_view_on_selected ( self , widget , selected_item_key ): \"\"\"The selection event of the listView, returns a key of the clicked event. You can retrieve the item rapidly \"\"\" self . lbl . set_text ( \"List selection: \" + self . listView . children [ selected_item_key ] . get_text () )","title":"list_view_on_selected()"},{"location":"api_docs/#obs_picamera.scripts.ui.MyApp.on_close","text":"Overloading App.on_close event to stop the Timer. Source code in obs_picamera/scripts/ui.py 490 491 492 493 494 495 def on_close ( self ): \"\"\"Overloading App.on_close event to stop the Timer.\"\"\" self . stop_flag = True self . running = False super () . on_close ()","title":"on_close()"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased 0.2.0 - 2023-02-04 Added Rudimentary GUI Save distance history with video Run via Fastapi 0.1.0 - 2023-01-31 Added Documentation 0.0.5 - 2023-01-31 Fixed re-introduce py39 (as raspbian has no 310 yet.) better camera settings, ring buffer tested. 0.0.4 - 2023-01-30 Fixed File handling from command line script Use of non-existant loop Rename command line scripts 0.0.3 - 2023-01-30 Added Bluetooth Unittests Command line script 0.0.2 - 2023-01-28 Added Set up github workflows and created pypi package","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#020-2023-02-04","text":"","title":"0.2.0 - 2023-02-04"},{"location":"changelog/#added","text":"Rudimentary GUI Save distance history with video Run via Fastapi","title":"Added"},{"location":"changelog/#010-2023-01-31","text":"","title":"0.1.0 - 2023-01-31"},{"location":"changelog/#added_1","text":"Documentation","title":"Added"},{"location":"changelog/#005-2023-01-31","text":"","title":"0.0.5 - 2023-01-31"},{"location":"changelog/#fixed","text":"re-introduce py39 (as raspbian has no 310 yet.) better camera settings, ring buffer tested.","title":"Fixed"},{"location":"changelog/#004-2023-01-30","text":"","title":"0.0.4 - 2023-01-30"},{"location":"changelog/#fixed_1","text":"File handling from command line script Use of non-existant loop Rename command line scripts","title":"Fixed"},{"location":"changelog/#003-2023-01-30","text":"","title":"0.0.3 - 2023-01-30"},{"location":"changelog/#added_2","text":"Bluetooth Unittests Command line script","title":"Added"},{"location":"changelog/#002-2023-01-28","text":"","title":"0.0.2 - 2023-01-28"},{"location":"changelog/#added_3","text":"Set up github workflows and created pypi package","title":"Added"}]}